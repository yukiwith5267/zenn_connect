---
title: "ã€ML-Agentsã€‘UnityÃ—å¼·åŒ–å­¦ç¿’ã§ãƒ‰ãƒ­ãƒ¼ãƒ³ã‚’è‡ªå‹•æ“ç¸¦ã—ãŸã„"
emoji: "ğŸ•"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: []
published: false
---

Unity ã§ ML-Agents ã‚’ç”¨ã„ã¦ã€ãƒ‰ãƒ­ãƒ¼ãƒ³ã‚’è‡ªå‹•æ“ç¸¦ã™ã‚‹AIãƒ¢ãƒ‡ãƒ«ã‚’å¼·åŒ–å­¦ç¿’ã§ä½œæˆã—ã¾ã—ãŸã€‚

### å®Œæˆãƒ¢ãƒ‡ãƒ«

![](https://storage.googleapis.com/zenn-user-upload/51adea844e4b-20230609.gif)


### What is ML-Agents?

ML-Agentsã¨ã¯[Unity Machine Learning Agents](https://unity.com/ja/products/machine-learning-agents)ã®ã“ã¨ã§ã€Unity ã‚’ä½¿ã£ã¦æ©Ÿæ¢°å­¦ç¿’ã‚’è¡Œã†ã“ã¨ã®ã§ãã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚

https://github.com/Unity-Technologies/ml-agents

[ã“ã“](https://github.com/Unity-Technologies/ml-agents)ã‹ã‚‰ã€ŒRelease 20ã€ã®ã€Œdownloadã€ã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã€Unityã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚


### ML-Agentsã«ã‚ˆã‚‹å¼·åŒ–å­¦ç¿’
- å¼·åŒ–å­¦ç¿’ã®å„è¦ç´ 

| é …ç›® | å†…å®¹ |
| --- | --- |
| è¡Œå‹• | ãƒ‰ãƒ­ãƒ¼ãƒ³ã®å·¦å³ç§»å‹•/å‰å¾Œç§»å‹•/ä¸Šæ˜‡/ä¸‹é™/å›è»¢ |
| å ±é…¬ | åŠ ç®—ï¼šãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®é€šéã€æ¸›ç®—ï¼šå£ã¸ã®è¡çª |
| è¦³å¯Ÿ | ãƒ‰ãƒ­ãƒ¼ãƒ³ã®é€Ÿåº¦/å›è»¢ |

```cs
using UnityEngine;
using Unity.MLAgents;
using Unity.MLAgents.Actuators;
using Unity.ãƒãƒãƒ¼ã‚¸ãƒ£MLAgents.Sensors;

// This is a public class called Player that inherits from another class called Agent
public class Player : Agent
{
    // These are public fields used to control the player's movement and tilt
    public float moveSpeed = 20f;
    public float rotSpeed = 100f;
    public float verticalForce = 17f;
    public float forwardTiltAmount = 0;
    public float sidewaysTiltAmount = 0;
    public float tiltVel = 2f;

    // These are private fields used for physics calculations and keeping track of checkpoints hit
    private Rigidbody playerRb;
    private float tiltAng = 45f;
    private int cptCount;

    // This method is called once when the agent is initialized. It finds the Rigidbody component on the game object.
    public override void Initialize()
    {
        playerRb = GetComponent<Rigidbody>();
    }

    // This method is called each time a new episode begins. It resets the player's position and velocity, as well as the checkpoint count.
    public override void OnEpisodeBegin()
    {
        cptCount = 0;
        transform.position = new Vector3(0, 10.0f, 0);
        transform.rotation = Quaternion.identity;
        playerRb.velocity = Vector3.zero;
        playerRb.angularVelocity = Vector3.zero;

        // Applies force to the player in the direction of (0, 200, 200) in global space.
        playerRb.AddForce(transform.TransformDirection(new Vector3(0, 200.0f, 200.0f)));
    }

    // This method is called whenever the player collides with a trigger collider.
    private void OnTriggerEnter(Collider other)
    {
        // If the collider has the tag "Checkpoint", it awards a reward and increases the checkpoint count. If the count reaches 4, it ends the episode and awards more points.
        if (other.CompareTag("CheckPoint"))
        {
            AddReward(1.0f);
            cptCount++;
            if (cptCount >= 4)
            {
                AddReward(10.0f);
                EndEpisode();
            }
        }
        // If the collider has the tag "Wall", it penalizes the player and ends the episode.
        else if (other.CompareTag("Wall"))
        {
            AddReward(-5.0f);
            EndEpisode();
        }
    }

    // This method is called each time the agent senses its environment, such as when the observation data is collected for the neural network.
    public override void CollectObservations(VectorSensor sensor)
    {
        sensor.AddObservation(playerRb.velocity);
        sensor.AddObservation(transform.rotation.eulerAngles);
    }

    // This method is called each time the agent receives an action from the neural network.
    public override void OnActionReceived(ActionBuffers actions)
    {
        // These are the continuous actions received in the buffer
        float horInput = actions.ContinuousActions[0];
        float verInput = actions.ContinuousActions[1];
        float upInput = actions.ContinuousActions[2];
        float downInput = actions.ContinuousActions[3];
        float rotInput = actions.ContinuousActions[4];

        // Calculates and applies force to move the player based on the input values.
        Vector3 moveDirection = new Vector3(horInput, 0, verInput) * moveSpeed;
        playerRb.AddForce(transform.TransformDirection(moveDirection));

        // Applies upward or downward force to the player based on the input values.
        if (upInput > 0)
        {
            playerRb.AddForce(Vector3.up * verticalForce * upInput);
        }

        if (downInput > 0)
        {
            playerRb.AddForce(Vector3.down * verticalForce * downInput);
        }

        // Applies rotational force to the player based on the input values.
        transform.Rotate(0, rotInput * rotSpeed * Time.fixedDeltaTime, 0);

        // Applies forward and sideways tilt to the player based on the input values.
        sidewaysTiltAmount = Mathf.Lerp(sidewaysTiltAmount, -horInput * tiltAng, tiltVel * Time.fixedDeltaTime);
        forwardTiltAmount = Mathf.Lerp(forwardTiltAmount, verInput * tiltAng, tiltVel * Time.fixedDeltaTime);

        Quaternion targetRot = Quaternion.Euler(forwardTiltAmount, 0, sidewaysTiltAmount);
        transform.localRotation = targetRot;
    }

    // This method is called during training when using a player-controlled agent. It maps user input to the action buffer.
    public override void Heuristic(in ActionBuffers actionsOut)
    {
        float horInput = Input.GetAxis("Horizontal");
        float verInput = Input.GetAxis("Vertical");
        float upInput = Input.GetKey(KeyCode.Space) ? 1 : 0;
        float downInput = Input.GetKey(KeyCode.LeftControl) ? 1 : 0;
        float rotInput = Input.GetAxis("Mouse X");

        ActionSegment<float> continuousAct = actionsOut.ContinuousActions;
        continuousAct[0] = horInput;
        continuousAct[1] = verInput;
        continuousAct[2] = upInput;
        continuousAct[3] = downInput;
        continuousAct[4] = rotInput;
    }
}
```
#### è¡çªæ¤œå‡º
PlayerãŒã‚²ãƒ¼ãƒ å†…ã®ãƒˆãƒªã‚¬ãƒ¼ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¨è¡çªã™ã‚‹ãŸã³ã«ã€`OnTriggerEnter`ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚
å£ã®ã‚¿ã‚°ã‚’`Wall`ã€ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®ã‚¿ã‚°ã‚’`CheckPoint`ã«è¨­å®šã—ã€
ã‚¿ã‚°ãŒ`CheckPoint`ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¡çªã—ãŸå ´åˆã€å ±é…¬ã‚’è¿½åŠ ã—ã€`cptCount`ã‚’å¢—ã‚„ã—ã¾ã™ã€‚ã™ã¹ã¦ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’é€šéã—ãŸå ´åˆã€ã‚´ãƒ¼ãƒ«å ±é…¬ã‚’è¿½åŠ ã—ã€ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™ã€‚
ä¸€æ–¹ã€ã‚¿ã‚°ãŒ`Wall`ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¡çªã—ãŸå ´åˆã€ãƒšãƒŠãƒ«ãƒ†ã‚£å ±é…¬ã‚’è¿½åŠ ã—ã€ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™ã€‚